{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to Home.</p>"},{"location":"developers/","title":"Index","text":""},{"location":"developers/#error-handling","title":"Error Handling","text":"<p>For every error that you want to return, just return if the Debug option is enabled:</p> <pre><code>import (\n    \"github.com/cfsdes/nucke/pkg/globals\"\n    \"github.com/fatih/color\"\n)\n\nif globals.Debug {\n    // Print error\n    Red := color.New(color.FgRed, color.Bold).SprintFunc()\n    fmt.Printf(\"[%s] Error message here\\n\", Red(\"ERR\"))\n\n    // Print Debug\n    Blue := color.New(color.FgBlue, color.Bold).SprintFunc()\n    fmt.Printf(\"[%s] Debug message here\\n\", Blue(\"DEBUG\"))\n}\n</code></pre>"},{"location":"developers/#profiler-debug-server","title":"Profiler Debug Server","text":"<p>If you start nucke with the <code>-stats</code> option, the profiler debug endpoint will be also available on <code>http://localhost:8899/debug/pprof/</code></p> <p>You can analyze:</p> <ul> <li>The <code>/debug/pprof/heap</code> to get information about memory alocation</li> <li>The <code>/debug/pprof/goroutine</code> to get information about go routines running</li> </ul>"},{"location":"developers/requests/","title":"Requests","text":"<p>Package</p> <pre><code>import \"github.com/cfsdes/nucke/pkg/requests\"\n</code></pre>"},{"location":"developers/requests/#send-request","title":"Send Request","text":"<p>Reproduce the request and return a slice of responses for each request made (redirects response + final response). <pre><code>responses := requests.Do(r, client)\n</code></pre></p> Returns Parameter Type Description <code>responses</code> <code>[]http.Response</code> Slice with all responses, including intermediate responses (3xx status code)"},{"location":"developers/requests/#send-basic-request","title":"Send Basic Request","text":"<pre><code>resTime, resBody, statusCode, resHeaders, rawResponse := requests.BasicRequest(r, client)\n</code></pre> Returns Parameter Type Description <code>resTime</code> <code>int</code> Response time in seconds <code>resBody</code> <code>string</code> Response body <code>statusCode</code> <code>string</code> Response Status Code <code>resHeaders</code> <code>string</code> Response Headers <code>rawResponse</code> <code>string</code> Raw Response (Path + Headers + Body) <code>err</code> <code>error</code> Error"},{"location":"developers/requests/#clone-request","title":"Clone Request","text":"<p>Every time you need to create new fuzzers or handle requests, use the clone request module to avoid problems.</p> <p>It's necessary because a request body cannot be read twice.</p> <pre><code>// Request cloned to be handled\nvar req *http.Request \nreq = requests.CloneReq(r)\n</code></pre>"},{"location":"developers/requests/#raw-request","title":"Raw Request","text":""},{"location":"developers/requests/#convert-request-to-raw","title":"Convert request to Raw","text":"<p>To get the raw request of a <code>req *http.Request</code> (return: <code>string</code>):</p> <pre><code>rawReq := requests.RequestToRaw(req)\n</code></pre>"},{"location":"developers/requests/#get-url-from-raw-request","title":"Get URL from Raw Request","text":"<p>To extract the raw url of the request (return: <code>string</code>):</p> <pre><code>url := requests.ExtractRawURL(rawReq)\n</code></pre>"},{"location":"developers/requests/#get-status-code-form-raw-response","title":"Get Status Code form Raw Response","text":"<p>returns: <code>string</code> <pre><code>resStatusCode := requests.StatusCodeFromRaw(rawResponse)\n</code></pre></p>"},{"location":"developers/requests/#parse-response","title":"Parse Response","text":"<p>Parses response type <code>*http.Response</code> and returns information:</p> <pre><code>statusCode, responseBody, responseHeaders, rawResponse := requests.ParseResponse(resp)\n</code></pre> Returns Parameter Type Description <code>statusCode</code> <code>string</code> Response Status Code <code>responseBody</code> <code>string</code> Response body <code>responseHeaders</code> <code>string</code> Response Headers <code>rawResponse</code> <code>string</code> Raw Response (Path + Headers + Body)"},{"location":"developers/requests/#check-authenticated-request","title":"Check Authenticated Request","text":"<p>It's possible to check if the request requires authentication using the following function:</p> <p><pre><code>requiresAuth := requests.CheckAuth(req, client)\n</code></pre> Returns: <code>bool</code></p>"},{"location":"developers/utils/","title":"Utils","text":"<p>Introduction</p> <p>Some random useful functions </p> <pre><code>import \"github.com/cfsdes/nucke/pkg/plugins/utils\"\n</code></pre>"},{"location":"developers/utils/#file-to-slice","title":"File To Slice","text":"<p>If you want to load a list of payloads or rules (or anything else), you can use the FileToSlice function:</p> <pre><code>payloads := utils.FileToSlice(pluginDir, \"payloads.txt\")\n</code></pre>"},{"location":"developers/utils/#similarity","title":"Similarity","text":"<p>Module to help you check the similarity between two texts. Returns a <code>float64</code> number representing the percentage of similarity (e.g.: 0.75)</p> <pre><code>text1 := \"This is one example\"\ntext2 := \"This is another example\"\n\nsimilarity := utils.TextSimilarity(text1, text2)\n</code></pre>"},{"location":"developers/utils/#replace-oob","title":"Replace OOB","text":"<p>Replace the \"{{.oob}}\" in the string with the interactsh url <pre><code>updatedPayload := utils.ReplaceOob(\"https://{{.oob}}\")\n</code></pre></p>"},{"location":"developers/utils/#extract-oob-id","title":"Extract OOB ID","text":"<p>Return the random ID appened to the OOB url: <pre><code>oob_id := ExtractOobID(updatedPayload)\n</code></pre></p>"},{"location":"getting-started/installation/","title":"Getting Started","text":"<p>Introduction</p> <p>Nucke is a powerful proxy that allows users to create custom vulnerability scanning plugins. It supports various fuzzing techniques and offers effortless customization, thanks to its ability to code plugins in Go.</p>"},{"location":"getting-started/installation/#features","title":"Features","text":"<ul> <li> Simple Proxy Server</li> <li> Flexible Vulnerability Scanner (Plugins)</li> </ul>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ol> <li> <p>Install interactsh: <pre><code>go install -v github.com/projectdiscovery/interactsh/cmd/interactsh-client@latest\n</code></pre></p> </li> <li> <p>Install redis</p> </li> </ol>"},{"location":"getting-started/installation/#nucke-installation","title":"Nucke Installation","text":"RemoteBuild From Source <pre><code>go install github.com/cfsdes/nucke@latest\n</code></pre> <pre><code>git clone git@github.com:cfsdes/nucke.git\ncd nucke/\ngo build\n</code></pre>"},{"location":"getting-started/installation/#configuring-ca-certificate","title":"Configuring CA certificate","text":"<p>Before using nucke, you must add the CA certificate in your browser to be able to intercept requests. To export the CA certificate: <pre><code>nucke -export-ca\nmv nucke-cert.crt /usr/local/share/ca-certificates/\nupdate-ca-certificates\n</code></pre></p>"},{"location":"getting-started/usage/","title":"Usage - Full usage message","text":""},{"location":"getting-started/usage/#practical-usage-with-examples-commands","title":"Practical Usage with examples commands","text":"<pre><code># Start a simple proxy server\nnucke\n\n# Load configuration file for plugin scan\nnucke -config config.yaml\n\n# List plugins\nnucke -config config.yaml -list-plugins\n\n# Send to another proxy the plugin scan requests\nnucke -config config.yaml -proxy \"http://127.0.0.1:8080\"\n\n# Scan with plugins and save output directory\nnucke -config config.yaml -out report\n\n# Set threads to scan (concurrency of urls to be scanned)\nnucke -config config.yaml -threads 50\n\n# Export CA certificate to install locally/in browser\nnucke -export-ca\n\n# Return debug error messages and requests received\nnucke -config config.yaml -debug\n\n# Add custom headers\nnucke -headers \"User-Agent: example\" -headers \"X-Forwarded-For: example.com\"\n\n# Start \"status\" server to get scan information (http://localhost:8899)\nnucke -config config.yaml -stats\n</code></pre>"},{"location":"plugins/detections/","title":"Detections","text":"<p>Introduction</p> <p>The Detections library is the one used to detect if a vulnerability was detected during the Fuzzers scan.</p> <pre><code>import \"github.com/cfsdes/nucke/pkg/plugins/detections\"\n</code></pre>"},{"location":"plugins/detections/#usage","title":"Usage","text":"<p>The detections accepts multiple matchers. You can use just one or combine multiple matchers to detect vulnerabilities.</p> <p>The matcher variable is passed later as a Fuzzer argument.</p> <pre><code>matcher := detections.Matcher{\n    Body: &amp;detections.BodyMatcher{\n        RegexList: []string{\"SQL Syntax\"},\n    },\n    Time: &amp;detections.TimeMatcher{\n        Operator: \"&gt;\", // Supports: \"==\", \"!=\", \"&gt;\", \"&lt;\", \"&gt;=\", \"&lt;=\"\n        Seconds:  10,\n    },\n    Header: &amp;detections.HeaderMatcher{\n        RegexList: []string{\"Content-Type: application/json\"},\n    },\n    StatusCode: &amp;detections.StatusCodeMatcher{\n        Operator: \"==\", // Supports: \"==\", \"!=\", \"&gt;\", \"&lt;\", \"&gt;=\", \"&lt;=\"\n        Code: 200,\n    },\n    ContentLength: &amp;detections.ContentLengthMatcher{\n        Operator: \"&gt;\",\n        Length: 1000,\n    },\n    OOB: true,\n    Operator: \"AND\", //Supports OR / AND operator\n}\n</code></pre> Matcher Description <code>Body</code> Check if the response body matches any regex of <code>RegexList</code> <code>Time</code> Compare the response time with the <code>Seconds</code> value using the <code>Operator</code> <code>Header</code> Check if header matches any regex of <code>RegexList</code> <code>StatusCode</code> Compare the response status code with the <code>Code</code> value using the <code>Operator</code> <code>ContentLength</code> Compare the body response length with the <code>Length</code> value using the <code>Operator</code> <code>OOB</code> Check if the parameter with <code>{{.oob}}</code> received any interaction <code>Operator</code> Logical operator to use when multiple matchers are used"},{"location":"plugins/fuzzers/","title":"Fuzzers","text":"<p>To make the creation of a plugin easy, our team developed the Fuzzers library. This library provides some functions that will allow you to create a plugin with a few lines of code.</p> <p>The idea of Fuzzers is to provide functions that receive a request and inject the payload on each parameter of the request and, based on the matchers specified, it will return if a vulnerability was identified or not.</p> <p>Remember</p> <p>Don't be restricted just to fuzzers library. They are pretty helpful, but don't forget: you can create your own fuzzers from zero, and this is the power of nucke!</p> <p>Package</p> <pre><code>import \"github.com/cfsdes/nucke/pkg/plugins/fuzzers\"\nimport \"github.com/cfsdes/nucke/pkg/plugins/detections\"\n</code></pre>"},{"location":"plugins/fuzzers/#example-usage","title":"Example Usage","text":"<p>Below is an example code of the usage of fuzzers:</p> Fuzzers Arguments Expected Parameter Type Description <code>r</code> <code>*http.Request</code> Request received by <code>Run()</code> func <code>client</code> <code>*http.Client</code> Client received by <code>Run()</code> func <code>payloads</code> <code>[]string</code> List of payloads to inject in the parameters <code>matcher</code> <code>[]string</code> Match rule used to identify the vulnerable behavior Fuzzers Returns Parameter Type Description <code>found</code> <code>bool</code> Boolean value. If true, the vulnerability was detected <code>url</code> <code>string</code> Vulnerable endpoint <code>payload</code> <code>string</code> Payload that matched the rule <code>param</code> <code>string</code> Vulnerable parameter injected <code>rawReq</code> <code>string</code> Raw Request <code>rawResp</code> <code>string</code> Raw/Full Response <code>logsScan</code> <code>[]detections.Result</code> If the scan doesn't return success, it will return an array containing all tests executed <p>The <code>logsScan</code> array contains the following properties:</p> <pre><code>- Found\n- URL\n- Payload\n- Param\n- RawReq\n- RawResp\n- ResBody\n</code></pre> <pre><code>// Set payloads and match rule\npayloads := []string{\"'\", \"1 OR 1=1\"}\n\nmatcher := detections.Matcher{\n    Body: &amp;detections.BodyMatcher{\n        RegexList: []string{\"SQL Syntax\"},\n    },\n}\n\n// Using fuzzer\nfound, url, payload, param, rawReq, rawResp, logsScan := fuzzers.Fuzz&lt;TYPE&gt;(r, client, pluginDir, payloads, matcher)\n</code></pre> <p>Matcher</p> <p>If you want to learn how to use matchers, access the Detections guide</p>"},{"location":"plugins/fuzzers/#fuzzers","title":"Fuzzers","text":""},{"location":"plugins/fuzzers/#fuzzing-queries","title":"Fuzzing Queries","text":"<pre><code>payloads := []string{\"'\", \"1 OR 1=1\"}\nfound, url, payload, param, rawReq, rawResp, logsScan := fuzzers.FuzzQuery(r, client, pluginDir, payloads, matcher)\n</code></pre>"},{"location":"plugins/fuzzers/#fuzzing-formdata","title":"Fuzzing FormData","text":"<pre><code>payloads := []string{\"'\", \"1 OR 1=1\"}\nfound, url, payload, param, rawReq, rawResp, logsScan := fuzzers.FuzzFormData(r, client, pluginDir, payloads, matcher)\n</code></pre>"},{"location":"plugins/fuzzers/#fuzzing-json","title":"Fuzzing JSON","text":"<pre><code>payloads := []string{\"'\", \"1 OR 1=1\"}\nfound, url, payload, param, rawReq, rawResp, logsScan := fuzzers.FuzzJSON(r, client, pluginDir, payloads, matcher)\n</code></pre>"},{"location":"plugins/fuzzers/#fuzzing-xml","title":"Fuzzing XML","text":"<pre><code>payloads := []string{\"'\", \"1 OR 1=1\"}\nfound, url, payload, param, rawReq, rawResp, logsScan := fuzzers.FuzzXML(r, client, pluginDir, payloads, matcher)\n</code></pre>"},{"location":"plugins/fuzzers/#all-fuzzers-at-once","title":"All fuzzers at once","text":"<pre><code>payloads := []string{\"'\", \"1 OR 1=1\"}\nfound, url, payload, param, rawReq, rawResp, logsScan := fuzzers.FuzzAll(r, client, pluginDir, payloads, matcher)\n</code></pre>"},{"location":"plugins/fuzzers/#special-fuzzers","title":"Special Fuzzers","text":""},{"location":"plugins/fuzzers/#fuzzing-headers","title":"Fuzzing Headers","text":"<pre><code>payloads := []string{\"'\", \"1 OR 1=1\"}\nheaders := []string{\"User-Agent\",\"Referer\"}\nfound, url, payload, param, rawReq, rawResp, logsScan := fuzzers.FuzzHeaders(r, client, pluginDir, payloads, headers, matcher, \"all\")\n</code></pre> <p>The last argument can be \"all\" or \"\". If \"all\", the payload will be added to all headers at once and sent in a single request.</p>"},{"location":"plugins/fuzzers/#fuzzing-path","title":"Fuzzing Path","text":"<pre><code>payloads := []string{\"'\", \"1 OR 1=1\"}\nfound, url, payload, param, rawReq, rawResp, logsScan := fuzzers.FuzzPath(r, client, pluginDir, payloads, matcher, \"last\")\n</code></pre> <p>The last argument can be \"last\" or \"*\". If last, only the last path will be fuzzed, else all paths will be fuzzed.</p>"},{"location":"plugins/fuzzers/#built-in-parameters","title":"Built-in parameters","text":"<p>You can add some special values to your payload and nucke will replace them automatically:</p> <ul> <li><code>{{.oob}}</code>: replace with oob interaction url (used during the OOB matcher)</li> <li><code>{{.original}}</code>: replace with original value of the parameter</li> </ul> <p>Example</p> <pre><code>payloads := []string{\n    \"https://{{.oob}}\",\n    \"{{.original}}' -- -\",\n}\n</code></pre> Add custom parameters <p>You can also add custom parameters to the fuzzers and specify its value using the \"-p\" option:</p> <p><code>{{.replaceme}}</code></p> <pre><code>nucke -p \"replaceme=test@123\"\n</code></pre>"},{"location":"plugins/introduction/","title":"Introduction","text":"<p>Plugins are the core of the Nucke. They are responsible for every scan that we can perform with the tool. For example, if you want to run an SQL injection scan on an application, you will need to use an SQL injection plugin for that.</p> Proposal <p>The proposal of Nucke is to be a completely flexible tool, allowing researchers to develop plugins to identify dynamic vulnerabilities of high complexity.</p> <p>The tool is not intended to be a CVE scanner. For that, we already have Nuclei, which fulfills this goal very well ;)</p>"},{"location":"plugins/introduction/#using-a-plugin","title":"Using a Plugin","text":"<p>To use a plugin, we need to create a configuration file and specify the directory where the plugin is located. By doing this, for each request received by Nucke, the plugin (scan) will be executed on the request.</p> <p>Example</p> <p>Below is an example of the configuration file: <code>config.yaml</code></p> <pre><code>scope: \".*example\\.com\" # Regex to filter scope to scan\nplugins:\n  - name: Example\n    path: ~/Desktop/plugins/\n    ids:\n      - \"*\" # It will load all plugins\n    exclude:\n      - xss-blind # Exclude specific plugins\n    webhook: \"https://webhook.com/event\" # Webhook to receive scan results\n</code></pre> <p>Remember: The plugin id should be the name of the plugin. E.g.: sample.go =&gt; sample</p> <p>To load the config file, just run nucke using <code>-config</code> argument:</p> <pre><code>nucke -config config.yaml\n</code></pre>"},{"location":"plugins/plugin-syntax/","title":"Creating Plugins","text":"<p>Plugins</p> <p>The plugins are written using Go programming language.</p>"},{"location":"plugins/plugin-syntax/#set-up-environment","title":"Set up Environment","text":""},{"location":"plugins/plugin-syntax/#install-dependencies","title":"Install dependencies","text":"<p>Before start creating the plugins, you must set up the environment.</p> <p>Let's first create the plugins' directory and install all required dependencies:</p> <pre><code>mkdir nucke-plugins &amp;&amp; cd nucke-plugins\ngo mod init nucke-plugins\ngo get github.com/cfsdes/nucke@latest\n</code></pre>"},{"location":"plugins/plugin-syntax/#directory-structure","title":"Directory Structure","text":"<p>The plugins created must have the following structure:</p> Example: Plugin Directory <pre><code>nucke-plugins/\n\u251c\u2500\u2500 go.mod\n\u251c\u2500\u2500 config.yaml\n\u251c\u2500\u2500 ssrf/\n\u2502   \u251c\u2500\u2500 ssrf.go\n\u2502   \u2514\u2500\u2500 report-template.md\n\u2514\u2500\u2500 sqli/\n    \u251c\u2500\u2500 sqli.go\n    \u2514\u2500\u2500 report-template.md\n</code></pre>"},{"location":"plugins/plugin-syntax/#updating-nucke","title":"Updating Nucke","text":"<p>If nucke version is different than the current version of go.mod, you must update it manually running the following commands: <pre><code>go get github.com/cfsdes/nucke@latest\ngo mod tidy\n</code></pre></p>"},{"location":"plugins/plugin-syntax/#specifications","title":"Specifications","text":"<p>A plugin code must have a <code>Run()</code> function. This function will be called by Nucke for each request received. It is the entrypoint to run the scan:</p> <pre><code>func Run(r *http.Request, client *http.Client, pluginDir string) (\n    found bool, \n    severity, \n    url, \n    payload, \n    param, \n    rawReq, \n    rawResp string,\n) {\n    // Scan logic here!\n}\n</code></pre> Returns <p>The <code>Run()</code> function should return:</p> Variable Description <code>found</code> Boolean value. If true, Nucke will report the vulnerability <code>severity</code> Severity of the vulnerability. Should be Critical, High, Medium, Low or Info <code>url</code> Vulnerable URL found <code>payload</code> Payload used to trigger the vuln <code>param</code> Affected parameter / Injection point <code>rawReq</code> Raw Request <code>rawResp</code> Raw Response Example: Plugin SQL Injection <pre><code>package main\n\nimport (\n    \"net/http\"\n    \"github.com/cfsdes/nucke/pkg/plugins/utils\"\n    \"github.com/cfsdes/nucke/pkg/plugins/fuzzers\"\n    \"github.com/cfsdes/nucke/pkg/plugins/detections\"\n)\n\n\nfunc Run(r *http.Request, client *http.Client, pluginDir string) (found bool, severity, url, payload, param, rawReq, rawResp string) {\n    severity = \"High\"\n\n    // Read rules file\n    rules := utils.FileToSlice(pluginDir, \"regex_match.txt\")\n\n    // Creating payload and matcher\n    payloads := []string{\"{{.original}}'\", \"{{.original}}\\\\\"}\n    matcher := detections.Matcher{\n        Body: &amp;detections.BodyMatcher{\n            RegexList: rules,\n        },\n    }\n\n    // Running All Fuzzers\n    found, url, payload, param, rawReq, rawResp, _ = fuzzers.FuzzAll(r, client, pluginDir, payloads, matcher)\n\n    return\n}\n</code></pre>"},{"location":"plugins/plugin-syntax/#plugin-workflow","title":"Plugin Workflow","text":"<p>Below is a representation of the plugin workflow and the phases that Nucke interacts with it.  <pre><code>sequenceDiagram\n  autonumber\n  Client-&gt;&gt;Nucke: Send Request\n  par\n    Nucke-&gt;&gt;Plugin: Foward Request to Plugin\n    Nucke-&gt;&gt;Client: Return Response\n  end\n\n  loop\n      Plugin-&gt;&gt;Plugin: Run Vulnerability Scan\n  end\n  Plugin-&gt;&gt;Nucke: Scan Result\n  loop\n    Note right of Nucke: vulnerability found?\n    Nucke-&gt;&gt;Nucke: Print Result\n  end</code></pre></p>"},{"location":"plugins/reporting/","title":"Reporting","text":"<p>Once a vulnerability is detected, nucke will create an automatic markdown report for the issue (if the option <code>-out</code> is specified).</p> <p>However, this report is 100% customizable. If you want to create your own report template to be used by a specific plugin, you can follow the steps below.</p>"},{"location":"plugins/reporting/#creating-a-report-template","title":"Creating a report template","text":"<p>To create a report template, you can simply create a new file in the same directory as the plugin, named <code>report-template.md</code> and add any information there. </p> <p>The report template support dynamic variables. A sample of a report template is shown below:</p> <pre><code>## Issue Details\n\n- **Scan Name**: {{.scanName}}\n- **Severity**: {{.severity}}\n- **Vulnerable Endpoint**: {{.url}}\n- **Injection Point**: {{.param}}\n\n## Proof of Concept\n\nThe payload below was used on **{{.param}}** to trigger the vulnerability:\n` + \"```\" + `\n{{.payload}}\n` + \"```\" + `\n\n### HTTP Request\nRequest:\n` + \"```http\" + `\n{{.request}}\n` + \"```\" + `\n\nResponse:\n` + \"```http\" + `\n{{.response}}\n</code></pre>"},{"location":"plugins/reporting/#custom-variables","title":"Custom variables","text":"Variable Description <code>{{.scanName}}</code> Return the name of the plugin <code>{{.severity}}</code> Severity for the vulnerability <code>{{.url}}</code> Vulnerable URL found <code>{{.payload}}</code> Payload used to trigger the vuln <code>{{.param}}</code> Affected parameter / Injection point <code>{{.request}}</code> Raw Request <code>{{.response}}</code> Raw Response"}]}